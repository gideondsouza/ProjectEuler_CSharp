/*
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?
 * http://projecteuler.net/problem=12
 * */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ProjectEuler.Problems
{
    public class Problem12 : IProblem
    {
        public void Run()
        {//don't think of skipping numbers, larger numbers don't have a larger number of divisors
            for (long i = 1; i <= long.MaxValue; i++)
            {
                decimal s = summation(i);//BIG BIG precision problems when I used float here               
                int d = DivisorCount(Convert.ToInt64(s));
                if (d > 500)
                {
                    Console.WriteLine(s);
                    break;
                }
            }
        }
        decimal summation(decimal n)//summation of a series of numbers from 1 to n. So a = 1 and d = 1
        {
            return (n * (1 + n)) / 2;
        }
        int DivisorCount(long n)
        {
            List<Tuple<long, int>> divCount = new List<Tuple<long, int>>();
            factors = new List<long>();
            Factors(n);
            var dist = factors.Distinct();
            int div = 1;
            foreach (var f in dist)
            {
                div *= (factors.Where(t => t == f).Count() + 1);
            }
            return div;
        }
        List<long> factors = new List<long>();
        void Factors(long n)
        {
            if (n <= 1) return;
            if (IsPrime(n))
            {
                factors.Add(n);//we're done now since this is a prime number we don't need to check for factors again, we know this is another factor by 1
                return;
            }
            for (long d = 2; d <= (n - 1); d++)
            {
                if (n % d == 0)
                {
                    factors.Add(d);
                    Factors(n / d);
                    break;
                }
            }
        }
        bool IsPrime(long n)
        {
            int c = 0;
            for (long i = 1; i < n; i++)
            {
                if (n % i == 0)
                {
                    c++;
                    if (c > 1) { return false; }//short-circuit.. we knw its not prime
                }
            }
            if (c == 1)
            {
                return true;
            }
            return false;
        }

    }
}
